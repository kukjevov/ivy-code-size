/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { NG_VALIDATORS } from '@angular/forms';
import { forwardRef, Directive, Attribute, Input } from '@angular/core';
import { isBlank, isPresent } from '@asseco/common';
import { Validators } from '../../misc';
/**
 * Validator that is injected with directive MinValueNumberValidatorDirective
 * @type {?}
 */
const MIN_NUMBER_VALIDATOR = (/** @type {?} */ ({
    provide: NG_VALIDATORS,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => MinValueNumberValidatorDirective)),
    multi: true
}));
/**
 * Directive injecting checking for number min value validator
 */
export class MinValueNumberValidatorDirective {
    //######################### constructor #########################
    /**
     * @param {?} minValue
     */
    constructor(minValue) {
        /**
         * Indication whether validator was initialized
         */
        this._initialized = false;
        /** @type {?} */
        var value;
        if (isBlank(minValue) || minValue.length < 1 || isNaN(value = parseFloat(minValue.replace(",", ".")))) {
            value = null;
        }
        this._minValue = value;
    }
    //######################### public methods - implementation of OnChanges #########################
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (!this._initialized) {
            this._initialized = true;
            this._validator = Validators.min(this._minValue);
        }
        if ('minValue' in changes) {
            this._validator = Validators.min(isPresent(this.minValue) ? (/** @type {?} */ ((/** @type {?} */ (this.minValue)))) : this._minValue);
        }
    }
    //######################### public methods - implementation of Validator #########################
    /**
     * Validates input and returns validation result
     * @param {?} control Control that is being validated
     * @return {?} validation results
     */
    validate(control) {
        return this._validator(control);
    }
}
MinValueNumberValidatorDirective.decorators = [
    { type: Directive, args: [{
                selector: "input[number][minValue][formControlName],input[number][minValue][formControl],input[number][minValue][ngModel]",
                providers: [MIN_NUMBER_VALIDATOR]
            },] }
];
/** @nocollapse */
MinValueNumberValidatorDirective.ctorParameters = () => [
    { type: String, decorators: [{ type: Attribute, args: ["minValue",] }] }
];
MinValueNumberValidatorDirective.propDecorators = {
    minValue: [{ type: Input }]
};
if (false) {
    /**
     * Current min value that is allowed
     * @type {?}
     * @private
     */
    MinValueNumberValidatorDirective.prototype._minValue;
    /**
     * Function used for validations
     * @type {?}
     * @private
     */
    MinValueNumberValidatorDirective.prototype._validator;
    /**
     * Indication whether validator was initialized
     * @type {?}
     * @private
     */
    MinValueNumberValidatorDirective.prototype._initialized;
    /**
     * Bound min value that is allowed, which overrides value set to attribute minValue
     * @type {?}
     */
    MinValueNumberValidatorDirective.prototype.minValue;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWluVmFsdWVOdW1iZXJWYWxpZGF0b3IuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2RpcmVjdGl2ZXMvbnVtYmVySW5wdXQvbWluVmFsdWVOdW1iZXJWYWxpZGF0b3IuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsYUFBYSxFQUE0RCxNQUFNLGdCQUFnQixDQUFDO0FBQ3hHLE9BQU8sRUFBQyxVQUFVLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQTZDLE1BQU0sZUFBZSxDQUFDO0FBQ2xILE9BQU8sRUFBQyxPQUFPLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFbEQsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFlBQVksQ0FBQzs7Ozs7TUFLaEMsb0JBQW9CLEdBQUcsbUJBQzdCO0lBQ0ksT0FBTyxFQUFFLGFBQWE7SUFDdEIsV0FBVyxFQUFFLFVBQVU7OztJQUFDLEdBQUcsRUFBRSxDQUFDLGdDQUFnQyxFQUFDO0lBQy9ELEtBQUssRUFBRSxJQUFJO0NBQ2QsRUFBQTs7OztBQVVELE1BQU0sT0FBTyxnQ0FBZ0M7Ozs7O0lBMkJ6QyxZQUFtQyxRQUFnQjs7OztRQVYzQyxpQkFBWSxHQUFZLEtBQUssQ0FBQzs7WUFZOUIsS0FBSztRQUVULElBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFDcEc7WUFDSSxLQUFLLEdBQUcsSUFBSSxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7SUFDM0IsQ0FBQzs7Ozs7O0lBSU0sV0FBVyxDQUFDLE9BQXNCO1FBRXJDLElBQUcsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUNyQjtZQUNJLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO1lBRXpCLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDcEQ7UUFFRCxJQUFJLFVBQVUsSUFBSSxPQUFPLEVBQ3pCO1lBQ0ksSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFRLG1CQUFBLElBQUksQ0FBQyxRQUFRLEVBQUMsRUFBQSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDeEc7SUFDTCxDQUFDOzs7Ozs7O0lBU00sUUFBUSxDQUFDLE9BQXdCO1FBRXBDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNwQyxDQUFDOzs7WUF2RUosU0FBUyxTQUNWO2dCQUNJLFFBQVEsRUFBRSxnSEFBZ0g7Z0JBQzFILFNBQVMsRUFBRSxDQUFDLG9CQUFvQixDQUFDO2FBQ3BDOzs7O3lDQTRCZ0IsU0FBUyxTQUFDLFVBQVU7Ozt1QkFKaEMsS0FBSzs7Ozs7Ozs7SUFoQk4scURBQStCOzs7Ozs7SUFLL0Isc0RBQWdDOzs7Ozs7SUFLaEMsd0RBQXNDOzs7OztJQU10QyxvREFDeUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge05HX1ZBTElEQVRPUlMsIEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdG9yLCBWYWxpZGF0b3JGbiwgVmFsaWRhdGlvbkVycm9yc30gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQge2ZvcndhcmRSZWYsIERpcmVjdGl2ZSwgQXR0cmlidXRlLCBJbnB1dCwgRXhpc3RpbmdQcm92aWRlciwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0Bhc3NlY28vY29tbW9uJztcclxuXHJcbmltcG9ydCB7VmFsaWRhdG9yc30gZnJvbSAnLi4vLi4vbWlzYyc7XHJcblxyXG4vKipcclxuICogVmFsaWRhdG9yIHRoYXQgaXMgaW5qZWN0ZWQgd2l0aCBkaXJlY3RpdmUgTWluVmFsdWVOdW1iZXJWYWxpZGF0b3JEaXJlY3RpdmVcclxuICovXHJcbmNvbnN0IE1JTl9OVU1CRVJfVkFMSURBVE9SID0gPEV4aXN0aW5nUHJvdmlkZXI+XHJcbntcclxuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXHJcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNaW5WYWx1ZU51bWJlclZhbGlkYXRvckRpcmVjdGl2ZSksXHJcbiAgICBtdWx0aTogdHJ1ZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpcmVjdGl2ZSBpbmplY3RpbmcgY2hlY2tpbmcgZm9yIG51bWJlciBtaW4gdmFsdWUgdmFsaWRhdG9yXHJcbiAqL1xyXG5ARGlyZWN0aXZlKFxyXG57XHJcbiAgICBzZWxlY3RvcjogXCJpbnB1dFtudW1iZXJdW21pblZhbHVlXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W251bWJlcl1bbWluVmFsdWVdW2Zvcm1Db250cm9sXSxpbnB1dFtudW1iZXJdW21pblZhbHVlXVtuZ01vZGVsXVwiLFxyXG4gICAgcHJvdmlkZXJzOiBbTUlOX05VTUJFUl9WQUxJREFUT1JdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNaW5WYWx1ZU51bWJlclZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIFZhbGlkYXRvciwgT25DaGFuZ2VzXHJcbntcclxuICAgIC8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBwcml2YXRlIGZpZWxkcyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IG1pbiB2YWx1ZSB0aGF0IGlzIGFsbG93ZWRcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfbWluVmFsdWU6IG51bWJlcnxudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdXNlZCBmb3IgdmFsaWRhdGlvbnNcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRpb24gd2hldGhlciB2YWxpZGF0b3Igd2FzIGluaXRpYWxpemVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX2luaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIHB1YmxpYyBwcm9wZXJ0aWVzIC0gaW5wdXRzICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgIC8qKlxyXG4gICAgICogQm91bmQgbWluIHZhbHVlIHRoYXQgaXMgYWxsb3dlZCwgd2hpY2ggb3ZlcnJpZGVzIHZhbHVlIHNldCB0byBhdHRyaWJ1dGUgbWluVmFsdWVcclxuICAgICAqL1xyXG4gICAgQElucHV0KClcclxuICAgIHB1YmxpYyBtaW5WYWx1ZT86IG51bWJlcjtcclxuXHJcbiAgICAvLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgY29uc3RydWN0b3IgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgY29uc3RydWN0b3IoQEF0dHJpYnV0ZShcIm1pblZhbHVlXCIpIG1pblZhbHVlOiBzdHJpbmcpXHJcbiAgICB7XHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG5cclxuICAgICAgICBpZihpc0JsYW5rKG1pblZhbHVlKSB8fCBtaW5WYWx1ZS5sZW5ndGggPCAxIHx8IGlzTmFOKHZhbHVlID0gcGFyc2VGbG9hdChtaW5WYWx1ZS5yZXBsYWNlKFwiLFwiLCBcIi5cIikpKSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX21pblZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIHB1YmxpYyBtZXRob2RzIC0gaW1wbGVtZW50YXRpb24gb2YgT25DaGFuZ2VzICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuXHJcbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcclxuICAgIHtcclxuICAgICAgICBpZighdGhpcy5faW5pdGlhbGl6ZWQpXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLm1pbih0aGlzLl9taW5WYWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoJ21pblZhbHVlJyBpbiBjaGFuZ2VzKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5taW4oaXNQcmVzZW50KHRoaXMubWluVmFsdWUpID8gPG51bWJlcj50aGlzLm1pblZhbHVlISA6IHRoaXMuX21pblZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIHB1YmxpYyBtZXRob2RzIC0gaW1wbGVtZW50YXRpb24gb2YgVmFsaWRhdG9yICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlcyBpbnB1dCBhbmQgcmV0dXJucyB2YWxpZGF0aW9uIHJlc3VsdFxyXG4gICAgICogQHBhcmFtIGNvbnRyb2wgQ29udHJvbCB0aGF0IGlzIGJlaW5nIHZhbGlkYXRlZFxyXG4gICAgICogQHJldHVybnMgdmFsaWRhdGlvbiByZXN1bHRzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB2YWxpZGF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzfG51bGxcclxuICAgIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yKGNvbnRyb2wpO1xyXG4gICAgfVxyXG59Il19
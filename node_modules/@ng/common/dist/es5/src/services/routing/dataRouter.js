/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { Router, NavigationEnd, NavigationError } from '@angular/router';
import { isPresent } from '@asseco/common';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
/**
 * Special implementation of router that allows routing with sending complex data to routed component
 */
var DataRouter = /** @class */ (function () {
    //######################### constructor #########################
    function DataRouter(_router) {
        var _this = this;
        this._router = _router;
        //######################### private fields #########################
        /**
         * Value that is going to be used for next routed data
         */
        this._nextValue = null;
        /**
         * Url path of next route
         */
        this._nextUrlPath = null;
        /**
         * Promise that resolves into value for current route
         */
        this._valuePromise = null;
        this._router.events.subscribe((/**
         * @param {?} next
         * @return {?}
         */
        function (next) {
            if (!(next instanceof NavigationEnd) && !(next instanceof NavigationError)) {
                return;
            }
            /** @type {?} */
            var error = next instanceof NavigationError;
            if (isPresent(_this._valuePromiseResolver) && isPresent(_this._nextUrlPath) && !error) {
                if (_this._nextUrlPath == next.url) {
                    _this._valuePromiseResolver(_this._nextValue);
                }
                else {
                    _this._valuePromiseResolver(null);
                }
            }
            else if (isPresent(_this._valuePromiseResolver)) {
                _this._valuePromiseResolver(null);
            }
            _this._nextUrlPath = null;
            _this._nextValue = null;
            _this._valuePromise = new Promise((/**
             * @param {?} resolve
             * @return {?}
             */
            function (resolve) {
                _this._valuePromiseResolver = resolve;
            }));
        }));
    }
    Object.defineProperty(DataRouter.prototype, "valuePromise", {
        //######################### public properties #########################
        /**
         * Gets promise that resolves into value for current route
         */
        get: 
        //######################### public properties #########################
        /**
         * Gets promise that resolves into value for current route
         * @return {?}
         */
        function () {
            return this._valuePromise || new Promise((/**
             * @param {?} resolve
             * @return {?}
             */
            function (resolve) {
                resolve(null);
            }));
        },
        enumerable: true,
        configurable: true
    });
    //######################### public methods #########################
    /**
     * Navigate based on the provided Route Link DSL. This method also allows you to provide complex data for your route
     * @param linkParams Link params that are used as for standard router
     * @param routeData Any type of object that can be passed to your routed component
     * @returns Promise
     */
    //######################### public methods #########################
    /**
     * Navigate based on the provided Route Link DSL. This method also allows you to provide complex data for your route
     * @param {?} linkParams Link params that are used as for standard router
     * @param {?} routeData Any type of object that can be passed to your routed component
     * @return {?} Promise
     */
    DataRouter.prototype.navigate = 
    //######################### public methods #########################
    /**
     * Navigate based on the provided Route Link DSL. This method also allows you to provide complex data for your route
     * @param {?} linkParams Link params that are used as for standard router
     * @param {?} routeData Any type of object that can be passed to your routed component
     * @return {?} Promise
     */
    function (linkParams, routeData) {
        this._nextValue = routeData;
        this._nextUrlPath = this._router.createUrlTree(linkParams).toString();
        return this._router.navigate(linkParams);
    };
    DataRouter.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    DataRouter.ctorParameters = function () { return [
        { type: Router }
    ]; };
    /** @nocollapse */ DataRouter.ngInjectableDef = i0.defineInjectable({ factory: function DataRouter_Factory() { return new DataRouter(i0.inject(i1.Router)); }, token: DataRouter, providedIn: "root" });
    return DataRouter;
}());
export { DataRouter };
if (false) {
    /**
     * Value that is going to be used for next routed data
     * @type {?}
     * @private
     */
    DataRouter.prototype._nextValue;
    /**
     * Url path of next route
     * @type {?}
     * @private
     */
    DataRouter.prototype._nextUrlPath;
    /**
     * Resolver function that is used for resolving routed value
     * @type {?}
     * @private
     */
    DataRouter.prototype._valuePromiseResolver;
    /**
     * Promise that resolves into value for current route
     * @type {?}
     * @private
     */
    DataRouter.prototype._valuePromise;
    /**
     * @type {?}
     * @private
     */
    DataRouter.prototype._router;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YVJvdXRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9zZXJ2aWNlcy9yb3V0aW5nL2RhdGFSb3V0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDekMsT0FBTyxFQUFDLE1BQU0sRUFBRSxhQUFhLEVBQUUsZUFBZSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDdkUsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7QUFLekM7SUFzQ0ksaUVBQWlFO0lBQ2pFLG9CQUFvQixPQUFlO1FBQW5DLGlCQW1DQztRQW5DbUIsWUFBTyxHQUFQLE9BQU8sQ0FBUTs7Ozs7UUEvQjNCLGVBQVUsR0FBUSxJQUFJLENBQUM7Ozs7UUFLdkIsaUJBQVksR0FBZ0IsSUFBSSxDQUFDOzs7O1FBVWpDLGtCQUFhLEdBQXNCLElBQUksQ0FBQztRQWtCNUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsU0FBUzs7OztRQUFDLFVBQUEsSUFBSTtZQUU5QixJQUFHLENBQUMsQ0FBQyxJQUFJLFlBQVksYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksWUFBWSxlQUFlLENBQUMsRUFDekU7Z0JBQ0ksT0FBTzthQUNWOztnQkFFRyxLQUFLLEdBQUcsSUFBSSxZQUFZLGVBQWU7WUFFM0MsSUFBRyxTQUFTLENBQUMsS0FBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksU0FBUyxDQUFDLEtBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssRUFDbEY7Z0JBQ0ksSUFBRyxLQUFJLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQ2hDO29CQUNJLEtBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7aUJBQy9DO3FCQUVEO29CQUNJLEtBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDcEM7YUFDSjtpQkFDSSxJQUFHLFNBQVMsQ0FBQyxLQUFJLENBQUMscUJBQXFCLENBQUMsRUFDN0M7Z0JBQ0ksS0FBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3BDO1lBRUQsS0FBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7WUFDekIsS0FBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7WUFFdkIsS0FBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLE9BQU87Ozs7WUFBQyxVQUFBLE9BQU87Z0JBRXBDLEtBQUksQ0FBQyxxQkFBcUIsR0FBRyxPQUFPLENBQUM7WUFDekMsQ0FBQyxFQUFDLENBQUM7UUFDUCxDQUFDLEVBQUMsQ0FBQztJQUNQLENBQUM7SUE1Q0Qsc0JBQVcsb0NBQVk7UUFMdkIsdUVBQXVFO1FBRXZFOztXQUVHOzs7Ozs7O1FBQ0g7WUFFSSxPQUFPLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxPQUFPOzs7O1lBQUMsVUFBQSxPQUFPO2dCQUU1QyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbEIsQ0FBQyxFQUFDLENBQUM7UUFDUCxDQUFDOzs7T0FBQTtJQXdDRCxvRUFBb0U7SUFFcEU7Ozs7O09BS0c7Ozs7Ozs7O0lBQ0ksNkJBQVE7Ozs7Ozs7O0lBQWYsVUFBZ0IsVUFBaUIsRUFBRSxTQUFjO1FBRTdDLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDO1FBQzVCLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFdEUsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM3QyxDQUFDOztnQkExRkosVUFBVSxTQUFDLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBQzs7OztnQkFOeEIsTUFBTTs7O3FCQURkO0NBa0dDLEFBM0ZELElBMkZDO1NBMUZZLFVBQVU7Ozs7Ozs7SUFPbkIsZ0NBQStCOzs7Ozs7SUFLL0Isa0NBQXlDOzs7Ozs7SUFLekMsMkNBQW1EOzs7Ozs7SUFLbkQsbUNBQWdEOzs7OztJQWdCcEMsNkJBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtSb3V0ZXIsIE5hdmlnYXRpb25FbmQsIE5hdmlnYXRpb25FcnJvcn0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0Bhc3NlY28vY29tbW9uJztcclxuXHJcbi8qKlxyXG4gKiBTcGVjaWFsIGltcGxlbWVudGF0aW9uIG9mIHJvdXRlciB0aGF0IGFsbG93cyByb3V0aW5nIHdpdGggc2VuZGluZyBjb21wbGV4IGRhdGEgdG8gcm91dGVkIGNvbXBvbmVudFxyXG4gKi9cclxuQEluamVjdGFibGUoe3Byb3ZpZGVkSW46ICdyb290J30pXHJcbmV4cG9ydCBjbGFzcyBEYXRhUm91dGVyXHJcbntcclxuICAgIC8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBwcml2YXRlIGZpZWxkcyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWx1ZSB0aGF0IGlzIGdvaW5nIHRvIGJlIHVzZWQgZm9yIG5leHQgcm91dGVkIGRhdGFcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfbmV4dFZhbHVlOiBhbnkgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXJsIHBhdGggb2YgbmV4dCByb3V0ZVxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9uZXh0VXJsUGF0aDogc3RyaW5nfG51bGwgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZXIgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIGZvciByZXNvbHZpbmcgcm91dGVkIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3ZhbHVlUHJvbWlzZVJlc29sdmVyOiAoZGF0YTogYW55KSA9PiB2b2lkO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIFByb21pc2UgdGhhdCByZXNvbHZlcyBpbnRvIHZhbHVlIGZvciBjdXJyZW50IHJvdXRlXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgX3ZhbHVlUHJvbWlzZTogUHJvbWlzZTxhbnk+fG51bGwgPSBudWxsO1xyXG5cclxuICAgIC8vIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyBwdWJsaWMgcHJvcGVydGllcyAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHByb21pc2UgdGhhdCByZXNvbHZlcyBpbnRvIHZhbHVlIGZvciBjdXJyZW50IHJvdXRlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXQgdmFsdWVQcm9taXNlKCk6IFByb21pc2U8YW55PlxyXG4gICAge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZVByb21pc2UgfHwgbmV3IFByb21pc2UocmVzb2x2ZSA9PlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgY29uc3RydWN0b3IgIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcm91dGVyOiBSb3V0ZXIpXHJcbiAgICB7XHJcbiAgICAgICAgdGhpcy5fcm91dGVyLmV2ZW50cy5zdWJzY3JpYmUobmV4dCA9PlxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYoIShuZXh0IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCkgJiYgIShuZXh0IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVycm9yKSlcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXh0IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVycm9yO1xyXG5cclxuICAgICAgICAgICAgaWYoaXNQcmVzZW50KHRoaXMuX3ZhbHVlUHJvbWlzZVJlc29sdmVyKSAmJiBpc1ByZXNlbnQodGhpcy5fbmV4dFVybFBhdGgpICYmICFlcnJvcilcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fbmV4dFVybFBhdGggPT0gbmV4dC51cmwpXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVQcm9taXNlUmVzb2x2ZXIodGhpcy5fbmV4dFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZVByb21pc2VSZXNvbHZlcihudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGlzUHJlc2VudCh0aGlzLl92YWx1ZVByb21pc2VSZXNvbHZlcikpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlUHJvbWlzZVJlc29sdmVyKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLl9uZXh0VXJsUGF0aCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX25leHRWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlUHJvbWlzZVJlc29sdmVyID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIHB1YmxpYyBtZXRob2RzICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5hdmlnYXRlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBSb3V0ZSBMaW5rIERTTC4gVGhpcyBtZXRob2QgYWxzbyBhbGxvd3MgeW91IHRvIHByb3ZpZGUgY29tcGxleCBkYXRhIGZvciB5b3VyIHJvdXRlXHJcbiAgICAgKiBAcGFyYW0gbGlua1BhcmFtcyBMaW5rIHBhcmFtcyB0aGF0IGFyZSB1c2VkIGFzIGZvciBzdGFuZGFyZCByb3V0ZXJcclxuICAgICAqIEBwYXJhbSByb3V0ZURhdGEgQW55IHR5cGUgb2Ygb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB5b3VyIHJvdXRlZCBjb21wb25lbnRcclxuICAgICAqIEByZXR1cm5zIFByb21pc2VcclxuICAgICAqL1xyXG4gICAgcHVibGljIG5hdmlnYXRlKGxpbmtQYXJhbXM6IGFueVtdLCByb3V0ZURhdGE6IGFueSk6IFByb21pc2U8YW55PlxyXG4gICAge1xyXG4gICAgICAgIHRoaXMuX25leHRWYWx1ZSA9IHJvdXRlRGF0YTtcclxuICAgICAgICB0aGlzLl9uZXh0VXJsUGF0aCA9IHRoaXMuX3JvdXRlci5jcmVhdGVVcmxUcmVlKGxpbmtQYXJhbXMpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3V0ZXIubmF2aWdhdGUobGlua1BhcmFtcyk7XHJcbiAgICB9XHJcbn1cclxuIl19
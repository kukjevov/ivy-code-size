/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ApplicationRef, InjectionToken } from "@angular/core";
import { enableDebugTools } from '@angular/platform-browser';
import { filter, first } from 'rxjs/operators';
/**
 * Method used for extraction of resolve method for promise
 * @param {?} appStablePromise Promise which contains resolve method that is going to be extracted
 * @return {?}
 */
export function extractAppStableResolve(appStablePromise) {
    return ((/** @type {?} */ (appStablePromise))).__resolve;
}
/**
 * Factory used for creating APP_STABLE promise
 * @return {?}
 */
export function appStablePromiseFactory() {
    /** @type {?} */
    var appStableResolve;
    /** @type {?} */
    var appStablePromise = new Promise((/**
     * @param {?} resolve
     * @return {?}
     */
    function (resolve) { return appStableResolve = resolve; }));
    ((/** @type {?} */ (appStablePromise))).__resolve = appStableResolve;
    return appStablePromise;
}
/**
 * Injection token used for obtaining promise that is resolved when application is first time stable
 * @type {?}
 */
export var APP_STABLE = new InjectionToken("APP_STABLE", { providedIn: 'root', factory: appStablePromiseFactory });
/**
 * Common utility methods
 */
var /**
 * Common utility methods
 */
Common = /** @class */ (function () {
    function Common() {
    }
    //######################### public methods #########################
    /**
     * Runs callback function when angular module is bootstrapped and stable
     * @param moduleRefPromise Promise for module that was bootstrapped
     * @param callback Callback that is called
     * @param angularProfiler Indication that angular profiler should be enabled
     */
    //######################### public methods #########################
    /**
     * Runs callback function when angular module is bootstrapped and stable
     * @param {?} moduleRefPromise Promise for module that was bootstrapped
     * @param {?} callback Callback that is called
     * @param {?=} angularProfiler Indication that angular profiler should be enabled
     * @return {?}
     */
    Common.runWhenModuleStable = 
    //######################### public methods #########################
    /**
     * Runs callback function when angular module is bootstrapped and stable
     * @param {?} moduleRefPromise Promise for module that was bootstrapped
     * @param {?} callback Callback that is called
     * @param {?=} angularProfiler Indication that angular profiler should be enabled
     * @return {?}
     */
    function (moduleRefPromise, callback, angularProfiler) {
        angularProfiler = angularProfiler || false;
        moduleRefPromise.then((/**
         * @param {?} moduleRef
         * @return {?}
         */
        function (moduleRef) {
            /** @type {?} */
            var appRef = moduleRef.injector.get(ApplicationRef);
            appRef.isStable
                .pipe(filter((/**
             * @param {?} isStable
             * @return {?}
             */
            function (isStable) { return isStable; })), first())
                .subscribe((/**
             * @return {?}
             */
            function () {
                /** @type {?} */
                var appStablePromise = moduleRef.injector.get(APP_STABLE);
                if (angularProfiler) {
                    enableDebugTools(appRef.components[0]);
                }
                callback(moduleRef);
                if (appStablePromise) {
                    /** @type {?} */
                    var resolveAsStable = extractAppStableResolve(appStablePromise);
                    resolveAsStable();
                }
            }));
        }));
    };
    return Common;
}());
/**
 * Common utility methods
 */
export default Common;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3V0aWxzL3V0aWxzLmNvbW1vbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFjLGNBQWMsRUFBRSxjQUFjLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDMUUsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDM0QsT0FBTyxFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7O0FBTTdDLE1BQU0sVUFBVSx1QkFBdUIsQ0FBQyxnQkFBK0I7SUFFbkUsT0FBTyxDQUFDLG1CQUFBLGdCQUFnQixFQUFPLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDL0MsQ0FBQzs7Ozs7QUFLRCxNQUFNLFVBQVUsdUJBQXVCOztRQUUvQixnQkFBZ0I7O1FBQ2hCLGdCQUFnQixHQUFHLElBQUksT0FBTzs7OztJQUFPLFVBQUEsT0FBTyxJQUFJLE9BQUEsZ0JBQWdCLEdBQUcsT0FBTyxFQUExQixDQUEwQixFQUFDO0lBRS9FLENBQUMsbUJBQUEsZ0JBQWdCLEVBQU8sQ0FBQyxDQUFDLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQztJQUV2RCxPQUFPLGdCQUFnQixDQUFDO0FBQzVCLENBQUM7Ozs7O0FBS0QsTUFBTSxLQUFPLFVBQVUsR0FBa0MsSUFBSSxjQUFjLENBQWdCLFlBQVksRUFBRSxFQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLHVCQUF1QixFQUFDLENBQUM7Ozs7QUFLaEs7Ozs7SUFBQTtJQXlDQSxDQUFDO0lBdkNHLG9FQUFvRTtJQUVwRTs7Ozs7T0FLRzs7Ozs7Ozs7O0lBQ1csMEJBQW1COzs7Ozs7Ozs7SUFBakMsVUFBa0MsZ0JBQTBDLEVBQUUsUUFBOEMsRUFBRSxlQUF5QjtRQUVuSixlQUFlLEdBQUcsZUFBZSxJQUFJLEtBQUssQ0FBQztRQUUzQyxnQkFBZ0IsQ0FBQyxJQUFJOzs7O1FBQUMsVUFBQyxTQUEwQjs7Z0JBRXZDLE1BQU0sR0FBbUIsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDO1lBRXJFLE1BQU0sQ0FBQyxRQUFRO2lCQUNWLElBQUksQ0FBQyxNQUFNOzs7O1lBQUMsVUFBQyxRQUFpQixJQUFLLE9BQUEsUUFBUSxFQUFSLENBQVEsRUFBQyxFQUN2QyxLQUFLLEVBQUUsQ0FBQztpQkFDYixTQUFTOzs7WUFBQzs7b0JBRUgsZ0JBQWdCLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDO2dCQUV6RCxJQUFHLGVBQWUsRUFDbEI7b0JBQ0ksZ0JBQWdCLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUMxQztnQkFFRCxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUE7Z0JBRW5CLElBQUcsZ0JBQWdCLEVBQ25COzt3QkFDUSxlQUFlLEdBQUcsdUJBQXVCLENBQUMsZ0JBQWdCLENBQUM7b0JBRS9ELGVBQWUsRUFBRSxDQUFDO2lCQUNyQjtZQUNMLENBQUMsRUFBQyxDQUFDO1FBQ1gsQ0FBQyxFQUFDLENBQUM7SUFDUCxDQUFDO0lBQ0wsYUFBQztBQUFELENBQUMsQUF6Q0QsSUF5Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge05nTW9kdWxlUmVmLCBBcHBsaWNhdGlvblJlZiwgSW5qZWN0aW9uVG9rZW59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XHJcbmltcG9ydCB7ZW5hYmxlRGVidWdUb29sc30gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XHJcbmltcG9ydCB7ZmlsdGVyLCBmaXJzdH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuLyoqXHJcbiAqIE1ldGhvZCB1c2VkIGZvciBleHRyYWN0aW9uIG9mIHJlc29sdmUgbWV0aG9kIGZvciBwcm9taXNlXHJcbiAqIEBwYXJhbSBhcHBTdGFibGVQcm9taXNlIFByb21pc2Ugd2hpY2ggY29udGFpbnMgcmVzb2x2ZSBtZXRob2QgdGhhdCBpcyBnb2luZyB0byBiZSBleHRyYWN0ZWRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0QXBwU3RhYmxlUmVzb2x2ZShhcHBTdGFibGVQcm9taXNlOiBQcm9taXNlPHZvaWQ+KTogKCkgPT4gdm9pZFxyXG57XHJcbiAgICByZXR1cm4gKGFwcFN0YWJsZVByb21pc2UgYXMgYW55KS5fX3Jlc29sdmU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGYWN0b3J5IHVzZWQgZm9yIGNyZWF0aW5nIEFQUF9TVEFCTEUgcHJvbWlzZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcFN0YWJsZVByb21pc2VGYWN0b3J5KClcclxue1xyXG4gICAgbGV0IGFwcFN0YWJsZVJlc29sdmU7XHJcbiAgICBsZXQgYXBwU3RhYmxlUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4gYXBwU3RhYmxlUmVzb2x2ZSA9IHJlc29sdmUpO1xyXG5cclxuICAgIChhcHBTdGFibGVQcm9taXNlIGFzIGFueSkuX19yZXNvbHZlID0gYXBwU3RhYmxlUmVzb2x2ZTtcclxuXHJcbiAgICByZXR1cm4gYXBwU3RhYmxlUHJvbWlzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluamVjdGlvbiB0b2tlbiB1c2VkIGZvciBvYnRhaW5pbmcgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gYXBwbGljYXRpb24gaXMgZmlyc3QgdGltZSBzdGFibGVcclxuICovXHJcbmV4cG9ydCBjb25zdCBBUFBfU1RBQkxFOiBJbmplY3Rpb25Ub2tlbjxQcm9taXNlPHZvaWQ+PiA9IG5ldyBJbmplY3Rpb25Ub2tlbjxQcm9taXNlPHZvaWQ+PihcIkFQUF9TVEFCTEVcIiwge3Byb3ZpZGVkSW46ICdyb290JywgZmFjdG9yeTogYXBwU3RhYmxlUHJvbWlzZUZhY3Rvcnl9KTtcclxuXHJcbi8qKlxyXG4gKiBDb21tb24gdXRpbGl0eSBtZXRob2RzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21tb25cclxue1xyXG4gICAgLy8jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIHB1YmxpYyBtZXRob2RzICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gYW5ndWxhciBtb2R1bGUgaXMgYm9vdHN0cmFwcGVkIGFuZCBzdGFibGVcclxuICAgICAqIEBwYXJhbSBtb2R1bGVSZWZQcm9taXNlIFByb21pc2UgZm9yIG1vZHVsZSB0aGF0IHdhcyBib290c3RyYXBwZWRcclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZFxyXG4gICAgICogQHBhcmFtIGFuZ3VsYXJQcm9maWxlciBJbmRpY2F0aW9uIHRoYXQgYW5ndWxhciBwcm9maWxlciBzaG91bGQgYmUgZW5hYmxlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIHJ1bldoZW5Nb2R1bGVTdGFibGUobW9kdWxlUmVmUHJvbWlzZTogUHJvbWlzZTxOZ01vZHVsZVJlZjx7fT4+LCBjYWxsYmFjazogKG1vZHVsZVJlZjogTmdNb2R1bGVSZWY8e30+KSA9PiB2b2lkLCBhbmd1bGFyUHJvZmlsZXI/OiBib29sZWFuKTogdm9pZFxyXG4gICAge1xyXG4gICAgICAgIGFuZ3VsYXJQcm9maWxlciA9IGFuZ3VsYXJQcm9maWxlciB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgbW9kdWxlUmVmUHJvbWlzZS50aGVuKChtb2R1bGVSZWY6IE5nTW9kdWxlUmVmPHt9PikgPT4gXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjb25zdCBhcHBSZWY6IEFwcGxpY2F0aW9uUmVmID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBcHBsaWNhdGlvblJlZik7XHJcblxyXG4gICAgICAgICAgICBhcHBSZWYuaXNTdGFibGVcclxuICAgICAgICAgICAgICAgIC5waXBlKGZpbHRlcigoaXNTdGFibGU6IGJvb2xlYW4pID0+IGlzU3RhYmxlKSxcclxuICAgICAgICAgICAgICAgICAgICAgIGZpcnN0KCkpXHJcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhcHBTdGFibGVQcm9taXNlID0gbW9kdWxlUmVmLmluamVjdG9yLmdldChBUFBfU1RBQkxFKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYW5ndWxhclByb2ZpbGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlRGVidWdUb29scyhhcHBSZWYuY29tcG9uZW50c1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhtb2R1bGVSZWYpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGFwcFN0YWJsZVByb21pc2UpXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzb2x2ZUFzU3RhYmxlID0gZXh0cmFjdEFwcFN0YWJsZVJlc29sdmUoYXBwU3RhYmxlUHJvbWlzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQXNTdGFibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSJdfQ==
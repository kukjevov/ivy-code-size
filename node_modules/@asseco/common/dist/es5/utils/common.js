import * as extendLib from 'extend';
import { isPresent } from './lang';
/**
 * Reverse current string and returns new reverse string
 * @param  {string} str String to be reversed
 * @returns string Reverse string
 */
export function reverseString(str) {
    return str.split("").reverse().join("");
}
export function extend(deepOrObject) {
    var objectN = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objectN[_i - 1] = arguments[_i];
    }
    return extendLib.apply(null, [deepOrObject].concat(objectN));
}
/**
 * Merges properties of two separate object into new third one
 * @param  {{[key: string]: any}} source1 First source object
 * @param  {{[key: string]: any}} source2 Second source object
 * @returns Object Object containing properties from source1 and source2 objects
 */
export function merge(source1, source2) {
    var resultObj = {};
    for (var attrname in source1) {
        resultObj[attrname] = source1[attrname];
    }
    for (var attrname in source2) {
        resultObj[attrname] = source2[attrname];
    }
    return resultObj;
}
/**
 * Generates random string consisting from lowercase letters
 * @param  {number} length Length of generated string
 * @returns number Generated string
 */
export function generateId(length) {
    var result = "";
    for (var x = 0; x < length; x++) {
        result += String.fromCharCode(Math.round(Math.random() * 25 + 97));
    }
    return result;
}
/**
 * Converts string in that way that first letter will be lowerCase
 * @param  {string} text Text to be converted
 */
export function firstToLowerCase(text) {
    return text.charAt(0).toLowerCase() + text.substr(1);
}
/**
 * Gets indication whether is child descendand of parent
 * @param parent Parent to be tested
 * @param child Child to be looked for
 */
export function isDescendant(parent, child) {
    var node = child.parentNode;
    while (node != null) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}
/**
 * Computes offset of element against document
 * @param element Html element which offset is counted
 * @param doc Html document to be used for extracting scroll offset
 */
export function offset(element, doc) {
    doc = doc || document;
    var rect = element.getBoundingClientRect(), scrollLeft = window.pageXOffset || doc.documentElement.scrollLeft, scrollTop = window.pageYOffset || doc.documentElement.scrollTop;
    return {
        top: rect.top + scrollTop,
        left: rect.left + scrollLeft,
        bottom: rect.top + scrollTop + rect.height,
        right: rect.left + scrollLeft + rect.width
    };
}
/**
 * Converts html string into html DOM
 * @param html Html string to be converted to DOM
 * @param doc Optional html document to be used
 */
export function htmlToElement(html, doc) {
    var htmlDocument = document;
    if (isPresent(doc)) {
        htmlDocument = doc;
    }
    var template = htmlDocument.createElement('template');
    html = html.trim();
    template.innerHTML = html;
    return template.content.firstChild;
}
/**
 * Extract values from enum type
 * @param enumType Enum type that will have extracted values
 */
export function getEnumValues(enumType) {
    var result = [];
    Object.keys(enumType).forEach(function (key) {
        if (isNaN(+key)) {
            return;
        }
        result.push({
            value: key,
            name: enumType[key]
        });
    });
    return result;
}
/**
 * Safely returns value from object property using string expression
 * @param object Object which property value will be obtained
 * @param expression Expression for obtaining value
 */
export function getValue(object, expression) {
    return expression.split('.').reduce(function (o, i) {
        if (o) {
            return o[i];
        }
        return null;
    }, object);
}
/**
 * Sets value to objects property using string expression
 * @param object Object which property value will be set
 * @param value Value that will be set
 * @param expression Expression for setting value
 */
export function setValue(object, value, expression) {
    var parts = expression.split('.');
    parts.forEach(function (part, index) {
        //last item value is assigned
        if (index == parts.length - 1) {
            if (isPresent(value)) {
                object[part] = value;
            }
            return;
        }
        object = object[part] = object[part] || {};
    });
}
//# sourceMappingURL=common.js.map
/**
 * Class for paging evaluation
 */
export class Paginator {
    constructor() {
        //######################### private fields ######################### 
        /**
         * First page set to paginator
         */
        this._base = 1;
        /**
         * Number of items per page
         */
        this._itemsPerPage = 10;
        /**
         * Index of current page
         */
        this._page = 1;
    }
    //######################### public methods #########################
    /**
     * Sets current page number.
     * @param  {number} page Page number
     * @returns Paginator Provides a fluent interface
     */
    setPage(page) {
        this._page = page;
        return this;
    }
    /**
     * Returns current page number.
     * @returns number Current page number
     */
    getPage() {
        return this._base + this.getPageIndex();
    }
    /// <summary>
    /// Returns first page number.
    /// </summary>
    /// <returns>Number of first page</returns>
    GetFirstPage() {
        return this._base;
    }
    /**
     * Returns last page number.
     * @returns number Number of last page
     */
    getLastPage() {
        return this._base + Math.max(0, this.getPageCount() - 1);
    }
    /**
     * Sets first page (base) number.
     * @param  {number} baseVal Index of base page
     * @returns Paginator Provides a fluent interface
     */
    setBase(baseVal) {
        this._base = baseVal;
        return this;
    }
    /**
     * Returns first page (base) number.
     * @returns number Index of base page
     */
    getBase() {
        return this._base;
    }
    /**
     * Gets indication whether is the current page the first one?
     * @returns boolean True if current page is first one
     */
    isFirst() {
        return this.getPageIndex() == 0;
    }
    /**
     * Gets indication whether is the current page the last one?
     * @returns boolean True if current page is last one, otherwise false
     */
    isLast() {
        return this.getPageIndex() == (this.getPageCount() - 1);
    }
    /**
     * Returns the total number of pages.
     * @returns number Total number of pages
     */
    getPageCount() {
        return Math.ceil(this._itemCount / this._itemsPerPage);
    }
    /**
     * Sets the number of items to display on a single page.
     * @param  {number} itemsPerPage Number of items per page
     * @returns Paginator Provides a fluent interface
     */
    setItemsPerPage(itemsPerPage) {
        this._itemsPerPage = Math.max(1, itemsPerPage);
        return this;
    }
    /**
     * Returns the number of items to display on a single page.
     * @returns number Number of items per one page
     */
    getItemsPerPage() {
        return this._itemsPerPage;
    }
    /**
     * Sets the total number of items.
     * @param  {number} itemCount Count of items or -1 for infinity
     * @returns Paginator Provides a fluent interface
     */
    setItemCount(itemCount) {
        this._itemCount = itemCount == -1 ? Number.MAX_VALUE : Math.max(0, itemCount);
        return this;
    }
    /**
     * Returns the total number of items.
     * @returns number Total number of items
     */
    getItemCount() {
        return this._itemCount;
    }
    /**
     * Returns the absolute index of the first item on current page.
     * @returns number Absolute index of first item
     */
    getOffset() {
        return this.getPageIndex() * this._itemsPerPage;
    }
    /**
     * Returns the absolute index of the first item on current page in countdown paging.
     * @returns number Countdown offset of first item
     */
    getCountdownOffset() {
        return Math.max(0, this._itemCount - (this.getPageIndex() + 1) * this._itemsPerPage);
    }
    /**
     * Returns the number of items on current page.
     * @returns number Number of items on page
     */
    getLength() {
        return Math.min(this._itemsPerPage, this._itemCount - this.getPageIndex() * this._itemsPerPage);
    }
    /**
     * Gets indexes for items on current page (zero-based indexes)
     * @returns number Array of items indexes
     */
    getIndexesPerPage() {
        let result = [];
        if (isNaN(this.getOffset())) {
            for (let x = 0; x < this.getItemCount(); x++) {
                result.push(x);
            }
        }
        else {
            for (let x = this.getOffset(); x < this.getOffset() + this.getLength(); x++) {
                result.push(x);
            }
        }
        return result;
    }
    /**
     * Gets list of page numbers with specified dispersion
     * @param  {number} dispersion Number identifying dispersion
     * @returns number Page numbers according specified dispersion
     */
    getPagesWithDispersion(dispersion) {
        var currentPage = this.getPage();
        var pageCount = this.getPageCount();
        var numberOfPages = Math.min(pageCount, Math.max(0, dispersion) * 2 + 1) - 1;
        var startingPage = Math.max(this._base, currentPage - dispersion);
        if ((currentPage + dispersion) > pageCount) {
            startingPage = pageCount - numberOfPages;
        }
        var x, endingPage = startingPage + numberOfPages;
        var result = [];
        for (x = startingPage; x <= endingPage; x++) {
            result.push(x);
        }
        return result;
    }
    /**
     * Gets list of page numbers with specified dispersion, pages are trimmed if current page is near beginning or end
     * @param  {number} dispersion Number identifying dispersion
     * @returns number Page numbers according specified dispersion
     */
    getPagesWithTrimDispersion(dispersion) {
        var currentPage = this.getPage();
        var lastPage = this.getLastPage();
        var startingPage = Math.max(this._base, currentPage - dispersion);
        var x, endingPage = Math.min(lastPage, currentPage + dispersion);
        var result = [];
        for (x = startingPage; x <= endingPage; x++) {
            result.push(x);
        }
        return result;
    }
    /**
     * Gets list of page numbers generated with uniform distribution
     * @param  {number} numberOfPages Number of pages that are going to be uniformly distributed between first and last page (including)
     * @returns number Uniformly distributed page numbers
     */
    getPagesWithUniformDistribution(numberOfPages) {
        numberOfPages = Math.max(1, numberOfPages - 1);
        var pageCount = this.getPageCount();
        numberOfPages = Math.min(numberOfPages, pageCount - 1);
        var step = pageCount / numberOfPages;
        var page = this.GetFirstPage();
        var x;
        var result = [];
        for (x = 0; x < numberOfPages; x++) {
            result.push(Math.round(page));
            page += step;
        }
        result.push(pageCount);
        return result;
    }
    //######################### protected methods #########################
    /**
     * Returns zero-based page number.
     * @returns number Zero-based page number
     */
    getPageIndex() {
        return Math.min(Math.max(0, this._page - this._base), Math.max(0, this.getPageCount() - 1));
    }
}
//# sourceMappingURL=paginator.js.map